
#
# This source file is part of appleseed.
# Visit http://appleseedhq.net/ for additional information and resources.
#
# This software is released under the MIT license.
#
# Copyright (c) 2010-2011 Francois Beaune
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

# Imports.
import bpy
import cProfile
import dis
from datetime import datetime
import math
import os


#
# Add-on information.
#

bl_info = {
    "name": "appleseed project format",
    "description": "Exports a scene to the appleseed project file format.",
    "author": "Franz Beaune",
    "version": (1, 1, 0),
    "blender": (2, 5, 8),   # we really need Blender 2.58 or newer
    "api": 36339,
    "location": "File > Export",
    "warning": "",
    "wiki_url": "",
    "tracker_url": "",
    "category": "Import-Export"}

script_name = "blenderseed.py"

def get_version_string():
    return "version " + ".".join(map(str, bl_info["version"]))


#
# Settings.
#

EnableProfiling = False


#
# Utilities.
#

def rad_to_deg(rad):
    return rad * 180.0 / math.pi

def scene_enumerator(self, context):
    matches = []
    for scene in bpy.data.scenes:
        matches.append((scene.name, scene.name, ""))
    return matches

def camera_enumerator(self, context):
    return object_enumerator('CAMERA')

def object_enumerator(type):
    matches = []
    for object in bpy.data.objects:
        if object.type == type:
            matches.append((object.name, object.name, ""))
    return matches


#
# Write a mesh object to disk in Wavefront OBJ format.
#

def get_array2_key(v):
    return int(v[0] * 1000000), int(v[1] * 1000000)

def get_vector2_key(v):
    w = v * 1000000
    return int(w.x), int(w.y)

def get_vector3_key(v):
    w = v * 1000000
    return int(w.x), int(w.y), int(w.z)

def write_mesh_object_to_disk(mesh, filepath):
    output_file = open(filepath, "w")

    # Write file header.
    output_file.write("# File generated by %s %s.\n" % (script_name, get_version_string()))

    vertices = mesh.vertices
    faces = mesh.faces
    uvtex = mesh.uv_textures
    uvset = uvtex.active.data if uvtex else None

    # Write vertices.
    output_file.write("# %d vertices.\n" % len(vertices))
    for vertex in vertices:
        v = vertex.co
        output_file.write("v %.15f %.15f %.15f\n" % (v.x, v.z, -v.y))

    # Deduplicate and write normals.
    output_file.write("# Vertex normals.\n")
    normal_indices = {}
    vertex_normal_indices = {}
    face_normal_indices = {}
    current_normal_index = 1
    for face_index, face in enumerate(faces):
        if face.use_smooth:
            for vertex_index in face.vertices:
                vn = vertices[vertex_index].normal
                vn_key = get_vector3_key(vn)
                if vn_key in normal_indices:
                    vertex_normal_indices[vertex_index] = normal_indices[vn_key]
                else:
                    output_file.write("vn %.15f %.15f %.15f\n" % (vn.x, vn.z, -vn.y))
                    normal_indices[vn_key] = current_normal_index
                    vertex_normal_indices[vertex_index] = current_normal_index
                    current_normal_index += 1
                    
        else:
            vn = face.normal
            vn_key = get_vector3_key(vn)
            if vn_key in normal_indices:
                face_normal_indices[face_index] = normal_indices[vn_key]
            else:
                output_file.write("vn %.15f %.15f %.15f\n" % (vn.x, vn.z, -vn.y))
                normal_indices[vn_key] = current_normal_index
                face_normal_indices[face_index] = current_normal_index
                current_normal_index += 1

    # Deduplicate and write texture coordinates.
    if uvset:
        output_file.write("# Texture coordinates.\n")
        vt_indices = {}
        vertex_texcoord_indices = {}
        current_vt_index = 1
        for face_index, face in enumerate(faces):
            assert len(uvset[face_index].uv) == len(face.vertices)
            for vt_index, vt in enumerate(uvset[face_index].uv):
                vertex_index = face.vertices[vt_index]
                vt_key = get_array2_key(vt)
                if vt_key in vt_indices:
                    vertex_texcoord_indices[face_index, vertex_index] = vt_indices[vt_key]
                else:
                    output_file.write("vt %.15f %.15f\n" % (vt[0], vt[1]))
                    vt_indices[vt_key] = current_vt_index
                    vertex_texcoord_indices[face_index, vertex_index] = current_vt_index
                    current_vt_index += 1

    # Write faces.
    output_file.write("# %d faces.\n" % len(faces))
    for face_index, face in enumerate(faces):
        line = "f"
        if uvset and len(uvset[face_index].uv) > 0:
            if face.use_smooth:
                for vertex_index in face.vertices:
                    texcoord_index = vertex_texcoord_indices[face_index, vertex_index]
                    normal_index = vertex_normal_indices[vertex_index]
                    line += " %d/%d/%d" % (vertex_index + 1, texcoord_index, normal_index)
            else:
                normal_index = face_normal_indices[face_index]
                for vertex_index in face.vertices:
                    texcoord_index = vertex_texcoord_indices[face_index, vertex_index]
                    line += " %d/%d/%d" % (vertex_index + 1, texcoord_index, normal_index)
        else:
            if face.use_smooth:
                for vertex_index in face.vertices:
                    normal_index = vertex_normal_indices[vertex_index]
                    line += " %d//%d" % (vertex_index + 1, normal_index)
            else:
                normal_index = face_normal_indices[face_index]
                for vertex_index in face.vertices:
                    line += " %d//%d" % (vertex_index + 1, normal_index)
        output_file.write(line + "\n")

    output_file.close()


#
# AppleseedExportOperator class.
#

class AppleseedExportOperator(bpy.types.Operator):
    bl_idname = "appleseed.export"
    bl_label = "Export"

    filepath = bpy.props.StringProperty(subtype='FILE_PATH')

    # In Blender 2.58 (since revision 36928), it is possible to pass a function to the 'items'
    # argument of bpy.props.EnumProperty to create a dynamic list.
    # See: http://projects.blender.org/scm/viewvc.php?view=rev&root=bf-blender&revision=36928
    selected_scene = bpy.props.EnumProperty(name="Scene",
                                            description="Select the scene to export",
                                            items=scene_enumerator)
    selected_camera = bpy.props.EnumProperty(name="Camera",
                                             description="Select the camera to export",
                                             items=camera_enumerator)

    def execute(self, context):
        if EnableProfiling:
            dis.dis(get_vector3_key)
            cProfile.runctx("self.export()", globals(), locals())
        else: self.export()
        return { 'FINISHED' }

    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return { 'RUNNING_MODAL' }
    
    def __get_selected_scene(self):
        if self.selected_scene is not None and self.selected_scene in bpy.data.scenes:
            return bpy.data.scenes[self.selected_scene]
        else: return None

    def __get_selected_camera(self):
        if self.selected_camera is not None and self.selected_camera in bpy.data.objects:
            return bpy.data.objects[self.selected_camera]
        else: return None

    def export(self):
        scene = self.__get_selected_scene()

        if scene is None:
            self.__error("No scene to export.")
            pass

        file_path = os.path.splitext(self.filepath)[0] + ".appleseed"

        self.__info("")
        self.__info("Starting export of scene '{0}' to {1}...".format(scene.name, file_path))

        start_time = datetime.now()

        try:
            with open(file_path, "w") as self._output_file:
                self._indent = 0
                self.__emit_file_header()
                self.__emit_project(scene)
        except IOError:
            self.__error("Could not write to {0}.".format(file_path))
            return

        elapsed_time = datetime.now() - start_time
        self.__info("Finished exporting in {0}".format(elapsed_time))

    def __emit_file_header(self):
        self.__emit_line("<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
        self.__emit_line("<!-- File generated by {0} {1}. -->".format(script_name, get_version_string()))

    def __emit_project(self, scene):
        self.__open_element("project")
        self.__emit_scene(scene)
        self.__emit_output(scene)
        self.__emit_configurations()
        self.__close_element("project")

    def __emit_scene(self, scene):
        self.__open_element("scene")
        self.__emit_camera(scene)
        self.__emit_assembly(scene)
        self.__emit_assembly_instance(scene)
        self.__close_element("scene")

    def __emit_camera(self, scene):
        camera = self.__get_selected_camera()

        if camera is None:
            self.__warning("No camera in the scene, exporting a default camera.")
            self.__emit_default_camera()
            return

        render = scene.render

        film_width = 32.0 / 1000                                # Blender's film width is hardcoded to 32 mm
        aspect_ratio = self.__get_frame_aspect_ratio(render)
        focal_length = camera.data.lens / 1000.0                # Blender's camera focal length is expressed in mm

        origin = camera.matrix_world[3]
        forward = -camera.matrix_world[2]
        up = camera.matrix_world[1]
        target = origin + forward

        self.__open_element('camera name="' + camera.name + '" model="pinhole_camera"')
        self.__emit_parameter("film_width", film_width)
        self.__emit_parameter("aspect_ratio", aspect_ratio)
        self.__emit_parameter("focal_length", focal_length)
        self.__open_element("transform")
        self.__emit_line('<look_at origin="{0} {1} {2}" target="{3} {4} {5}" up="{6} {7} {8}" />'.format( \
                         origin[0], origin[2], -origin[1],
                         target[0], target[2], -target[1],
                         up[0], up[2], -up[1]))
        self.__close_element("transform")
        self.__close_element("camera")

    def __emit_default_camera(self):
        self.__open_element('camera name="camera" model="pinhole_camera"')
        self.__emit_parameter("film_width", 0.024892)
        self.__emit_parameter("film_height", 0.018669)
        self.__emit_parameter("focal_length", 0.035)
        self.__close_element("camera")
        return

    def __emit_assembly(self, scene):
        self.__open_element('assembly name="' + scene.name + '"')
        self.__emit_objects(scene)
        self.__close_element("assembly")

    def __emit_objects(self, scene):
        for object in scene.objects:
            # Skip irrelevant objects.
            if object.type in ( 'CAMERA', 'EMPTY', 'LAMP' ):
                continue

            # Skip non-renderable objects.
            if object.hide_render:
                continue

            # Skip children of dupli objects.
            if object.parent and object.parent.dupli_type != 'NONE':
                continue

            # Create dupli list.
            if object.dupli_type != 'NONE':
                object.dupli_list_create(scene)
                instances = [ (dupli.object, dupli.matrix) for dupli in object.dupli_list ]
            else:
                instances = [ (object, object.matrix_world) ]

            # Emit object.
            first_instance = instances[0]
            emitted_mesh_object = self.__emit_mesh_object(scene, first_instance[0], first_instance[0].name)

            # Emit instances.
            if emitted_mesh_object:
                for index, instance in enumerate(instances):
                    object_name = first_instance[0].name
                    instance_name = "{0}_inst.{1}".format(object_name, index)
                    self.__emit_object_instance(object_name, instance_name, instance[1])

            # Clear dupli list.
            if object.dupli_type != 'NONE':
                object.dupli_list_clear()

    def __emit_mesh_object(self, scene, object, output_object_name):
        try:
            mesh = object.to_mesh(scene, True, 'RENDER')
            if mesh is None:
                self.__info("Object '{0}' of type '{1}' is not convertible to a mesh.".format(object.name, object.type))
                return False
            if len(mesh.faces) == 0:
                self.__info("Skipping object '{0}' since it has no faces once converted to a mesh.".format(object.name))
                return False
            emitted_mesh_object = self.__emit_object(output_object_name, mesh)
            bpy.data.meshes.remove(mesh)
            return emitted_mesh_object
        except RuntimeError:
            self.__info("Object '{0}' of type '{1}' is not convertible to a mesh.".format(object.name, object.type))
            return False

    def __emit_object(self, object_name, mesh):
        # Recalculate vertex normals.
        # todo: make this step optional?
        mesh.calc_normals()

        filename = object_name + ".obj"
        filepath = os.path.join(os.path.dirname(self.filepath), filename)

        try:
            self.__progress("Exporting object '{0}' to {1}...".format(object_name, filename))
            write_mesh_object_to_disk(mesh, filepath)
        except IOError:
            self.__error("While exporting object '{0}': could not write to {1}, skipping this object.".format(object_name, filepath))
            return False

        self.__open_element('object name="' + object_name + '" model="mesh_object"')
        self.__emit_parameter("filename", filename)
        self.__close_element("object")

        return True

    def __emit_object_instance(self, object_name, instance_name, instance_matrix):
        self.__open_element('object_instance name="{0}" object="{1}.0"'.format(instance_name, object_name))
        self.__emit_transform(instance_matrix)
        self.__close_element("object_instance")

    def __emit_assembly_instance(self, scene):
        self.__open_element('assembly_instance name="' + scene.name + '_inst" assembly="' + scene.name + '"')
        self.__close_element("assembly_instance")

    def __emit_output(self, scene):
        self.__open_element("output")
        self.__emit_frame(scene)
        self.__close_element("output")

    def __emit_frame(self, scene):
        camera = self.__get_selected_camera()
        render = scene.render

        width, height = self.__get_frame_resolution(render)

        self.__open_element("frame name=\"beauty\"")
        self.__emit_parameter("camera", "camera" if camera is None else camera.name)
        self.__emit_parameter("resolution", "{0} {1}".format(width, height))
        self.__emit_custom_prop(scene, "color_space", "srgb")
        self.__close_element("frame")

    def __get_frame_resolution(self, render):
        scale = render.resolution_percentage / 100.0
        width = int(render.resolution_x * scale)
        height = int(render.resolution_y * scale)
        return width, height

    def __get_frame_aspect_ratio(self, render):
        width, height = self.__get_frame_resolution(render)
        xratio = width * render.pixel_aspect_x
        yratio = height * render.pixel_aspect_y
        return xratio / yratio

    def __emit_configurations(self):
        self.__open_element("configurations")
        self.__emit_configuration("final", "base_final")
        self.__emit_configuration("interactive", "base_interactive")
        self.__close_element("configurations")

    def __emit_configuration(self, name, base):
        self.__open_element("configuration name=\"" + name + "\" base=\"" + base + "\"")
        self.__close_element("configuration")

    def __emit_transform(self, matrix):
        s = matrix.to_scale()
        t = matrix.to_translation()
        rx, ry, rz = map(rad_to_deg, matrix.to_euler())

        self.__open_element("transform")
        self.__emit_line('<scaling value="{0} {1} {2}" />'.format(s[0], s[2], s[1]))
        self.__emit_line('<rotation axis="1.0 0.0 0.0" angle="{0}" />'.format(rx))
        self.__emit_line('<rotation axis="0.0 0.0 -1.0" angle="{0}" />'.format(ry))
        self.__emit_line('<rotation axis="0.0 1.0 0.0" angle="{0}" />'.format(rz))
        self.__emit_line('<translation value="{0} {1} {2}" />'.format(t[0], t[2], -t[1]))
        self.__close_element("transform")

    def __emit_custom_prop(self, object, prop_name, default_value):
        value = self.__get_custom_prop(object, prop_name, default_value)
        self.__emit_parameter(prop_name, value)

    def __get_custom_prop(self, object, prop_name, default_value):
        if prop_name in object:
            return object[prop_name]
        else:
            return default_value

    def __emit_parameter(self, name, value):
        self.__emit_line("<parameter name=\"" + name + "\" value=\"" + str(value) + "\" />")

    def __open_element(self, name):
        self.__emit_line("<" + name + ">")
        self.__indent()

    def __close_element(self, name):
        self.__unindent()
        self.__emit_line("</" + name + ">")

    def __emit_line(self, line):
        self.__emit_indent()
        self._output_file.write(line + "\n")

    def __indent(self):
        self._indent += 1

    def __unindent(self):
        assert self._indent > 0
        self._indent -= 1

    def __emit_indent(self):
        IndentSize = 4
        self._output_file.write(" " * self._indent * IndentSize)

    def __error(self, message):
        self.__print_message("error", message)
        self.report({ 'ERROR' }, message)

    def __warning(self, message):
        self.__print_message("warning", message)
        self.report({ 'WARNING' }, message)

    def __info(self, message):
        if len(message) > 0:
            self.__print_message("info", message)
        else: print("")
        self.report({ 'INFO' }, message)

    def __progress(self, message):
        self.__print_message("progress", message)

    def __print_message(self, severity, message):
        max_length = 8  # length of the longest severity string
        padding_count = max_length - len(severity)
        padding = " " * padding_count
        print("[{0}] {1}{2} : {3}".format(script_name, severity, padding, message))


#
# Hook into Blender.
#

def menu_func(self, context):
    default_path = os.path.splitext(bpy.data.filepath)[0] + ".appleseed"
    self.layout.operator(AppleseedExportOperator.bl_idname, text="appleseed (.appleseed)").filepath = default_path

def register():
    bpy.utils.register_module(__name__)
    bpy.types.INFO_MT_file_export.append(menu_func)

def unregister():
    bpy.types.INFO_MT_file_export.remove(menu_func)
    bpy.utils.unregister_module(__name__)


#
# Entry point.
#

if __name__ == "__main__":
    register()
