
#
# This source file is part of appleseed.
# Visit http://appleseedhq.net/ for additional information and resources.
#
# This software is released under the MIT license.
#
# Copyright (c) 2010-2011 Francois Beaune
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#

# Imports.
import bpy
import cProfile
import dis
from datetime import datetime
import math
import mathutils
import os


#
# Add-on information.
#

bl_info = {
    "name": "appleseed project format",
    "description": "Exports a scene to the appleseed project file format.",
    "author": "Franz Beaune",
    "version": (1, 1, 0),
    "blender": (2, 5, 8),   # we really need Blender 2.58 or newer
    "api": 36339,
    "location": "File > Export",
    "warning": "",
    "wiki_url": "",
    "tracker_url": "",
    "category": "Import-Export"}

script_name = "blenderseed.py"

def get_version_string():
    return "version " + ".".join(map(str, bl_info["version"]))


#
# Settings.
#

EnableProfiling = False


#
# Utilities.
#

def rad_to_deg(rad):
    return rad * 180.0 / math.pi

def is_black(color):
    return color[0] == 0.0 and color[1] == 0.0 and color[2] == 0.0

def scene_enumerator(self, context):
    matches = []
    for scene in bpy.data.scenes:
        matches.append((scene.name, scene.name, ""))
    return matches

def camera_enumerator(self, context):
    return object_enumerator('CAMERA')

def object_enumerator(type):
    matches = []
    for object in bpy.data.objects:
        if object.type == type:
            matches.append((object.name, object.name, ""))
    return matches


#
# Write a mesh object to disk in Wavefront OBJ format.
#

def get_array2_key(v):
    return int(v[0] * 1000000), int(v[1] * 1000000)

def get_vector2_key(v):
    w = v * 1000000
    return int(w.x), int(w.y)

def get_vector3_key(v):
    w = v * 1000000
    return int(w.x), int(w.y), int(w.z)

def write_mesh_to_disk(mesh, filepath):
    with open(filepath, "w") as output_file:
        # Write file header.
        output_file.write("# File generated by %s %s.\n" % (script_name, get_version_string()))

        vertices = mesh.vertices
        faces = mesh.faces
        uvtex = mesh.uv_textures
        uvset = uvtex.active.data if uvtex else None

        # Write vertices.
        output_file.write("# %d vertices.\n" % len(vertices))
        for vertex in vertices:
            v = vertex.co
            output_file.write("v %.15f %.15f %.15f\n" % (v.x, v.z, -v.y))

        # Deduplicate and write normals.
        output_file.write("# Vertex normals.\n")
        normal_indices = {}
        vertex_normal_indices = {}
        face_normal_indices = {}
        current_normal_index = 1
        for face_index, face in enumerate(faces):
            if face.use_smooth:
                for vertex_index in face.vertices:
                    vn = vertices[vertex_index].normal
                    vn_key = get_vector3_key(vn)
                    if vn_key in normal_indices:
                        vertex_normal_indices[vertex_index] = normal_indices[vn_key]
                    else:
                        output_file.write("vn %.15f %.15f %.15f\n" % (vn.x, vn.z, -vn.y))
                        normal_indices[vn_key] = current_normal_index
                        vertex_normal_indices[vertex_index] = current_normal_index
                        current_normal_index += 1
            else:
                vn = face.normal
                vn_key = get_vector3_key(vn)
                if vn_key in normal_indices:
                    face_normal_indices[face_index] = normal_indices[vn_key]
                else:
                    output_file.write("vn %.15f %.15f %.15f\n" % (vn.x, vn.z, -vn.y))
                    normal_indices[vn_key] = current_normal_index
                    face_normal_indices[face_index] = current_normal_index
                    current_normal_index += 1

        # Deduplicate and write texture coordinates.
        if uvset:
            output_file.write("# Texture coordinates.\n")
            vt_indices = {}
            vertex_texcoord_indices = {}
            current_vt_index = 1
            for face_index, face in enumerate(faces):
                assert len(uvset[face_index].uv) == len(face.vertices)
                for vt_index, vt in enumerate(uvset[face_index].uv):
                    vertex_index = face.vertices[vt_index]
                    vt_key = get_array2_key(vt)
                    if vt_key in vt_indices:
                        vertex_texcoord_indices[face_index, vertex_index] = vt_indices[vt_key]
                    else:
                        output_file.write("vt %.15f %.15f\n" % (vt[0], vt[1]))
                        vt_indices[vt_key] = current_vt_index
                        vertex_texcoord_indices[face_index, vertex_index] = current_vt_index
                        current_vt_index += 1

        # Sort the faces by material.
        sorted_faces = sorted(faces, key=lambda face: face.material_index)

        # Write faces.
        output_file.write("# %d faces.\n" % len(sorted_faces))
        current_material_index = -1
        for face_index, face in enumerate(sorted_faces):
            if current_material_index != face.material_index:
                current_material_index = face.material_index
                output_file.write("o part_%d\n" % current_material_index)
            line = "f"
            if uvset and len(uvset[face_index].uv) > 0:
                if face.use_smooth:
                    for vertex_index in face.vertices:
                        texcoord_index = vertex_texcoord_indices[face_index, vertex_index]
                        normal_index = vertex_normal_indices[vertex_index]
                        line += " %d/%d/%d" % (vertex_index + 1, texcoord_index, normal_index)
                else:
                    normal_index = face_normal_indices[face_index]
                    for vertex_index in face.vertices:
                        texcoord_index = vertex_texcoord_indices[face_index, vertex_index]
                        line += " %d/%d/%d" % (vertex_index + 1, texcoord_index, normal_index)
            else:
                if face.use_smooth:
                    for vertex_index in face.vertices:
                        normal_index = vertex_normal_indices[vertex_index]
                        line += " %d//%d" % (vertex_index + 1, normal_index)
                else:
                    normal_index = face_normal_indices[face_index]
                    for vertex_index in face.vertices:
                        line += " %d//%d" % (vertex_index + 1, normal_index)
            output_file.write(line + "\n")


def write_sphere_mesh_to_disk(filepath):
    with open(filepath, "w") as output_file:
        output_file.write( \
"""v 0.500000 1.866025 0.000000
v 0.866025 1.500000 0.000000
v 1.000000 1.000000 0.000000
v 0.866025 0.500000 0.000000
v 0.500000 0.133975 0.000000
v 0.433013 1.866025 0.250000
v 0.750000 1.500000 0.433013
v 0.866025 1.000000 0.500000
v 0.750000 0.500000 0.433013
v 0.433013 0.133975 0.250000
v 0.250000 1.866025 0.433013
v 0.433013 1.500000 0.750000
v 0.500000 1.000000 0.866025
v 0.433013 0.500000 0.750000
v 0.250000 0.133975 0.433013
v -0.000000 1.866025 0.500000
v -0.000000 1.500000 0.866025
v -0.000000 1.000000 1.000000
v -0.000000 0.500000 0.866025
v -0.000000 0.133975 0.500000
v -0.250000 1.866025 0.433013
v -0.433013 1.500000 0.750000
v -0.500000 1.000000 0.866025
v -0.433013 0.500000 0.750000
v -0.250000 0.133975 0.433013
v -0.433013 1.866025 0.250000
v -0.750000 1.500000 0.433013
v -0.866025 1.000000 0.500000
v -0.750000 0.500000 0.433013
v -0.433013 0.133975 0.250000
v -0.500000 1.866025 -0.000000
v -0.866025 1.500000 -0.000000
v -1.000000 1.000000 -0.000000
v -0.866025 0.500000 -0.000000
v -0.500000 0.133975 -0.000000
v -0.433013 1.866025 -0.250000
v -0.750000 1.500000 -0.433013
v -0.866025 1.000000 -0.500000
v -0.750000 0.500000 -0.433013
v -0.433013 0.133975 -0.250000
v -0.250000 1.866025 -0.433013
v -0.433013 1.500000 -0.750000
v -0.500000 1.000000 -0.866025
v -0.433013 0.500000 -0.750000
v -0.250000 0.133975 -0.433013
v 0.000000 1.866025 -0.500000
v 0.000000 1.500000 -0.866025
v 0.000000 1.000000 -1.000000
v 0.000000 0.500000 -0.866025
v 0.000000 0.133975 -0.500000
v 0.250000 1.866025 -0.433013
v 0.433013 1.500000 -0.750000
v 0.500000 1.000000 -0.866025
v 0.433013 0.500000 -0.750000
v 0.250000 0.133975 -0.433013
v 0.433013 1.866025 -0.250000
v 0.750000 1.500000 -0.433013
v 0.866025 1.000000 -0.500000
v 0.750000 0.500000 -0.433013
v 0.433013 0.133975 -0.250000
v 0.000000 2.000000 0.000000
v 0.000000 0.000000 0.000000
vn 0.498231 0.867044 -0.000000
vn 0.865033 0.501714 -0.000000
vn 1.000000 0.000000 -0.000000
vn 0.865033 -0.501715 -0.000000
vn 0.498231 -0.867044 -0.000000
vn 0.431481 0.867044 0.249116
vn 0.749141 0.501714 0.432517
vn 0.866025 -0.000000 0.500000
vn 0.749141 -0.501714 0.432517
vn 0.431481 -0.867044 0.249116
vn 0.249116 0.867044 0.431481
vn 0.432517 0.501714 0.749141
vn 0.500000 -0.000000 0.866025
vn 0.432517 -0.501714 0.749141
vn 0.249116 -0.867044 0.431481
vn -0.000000 0.867044 0.498231
vn -0.000000 0.501714 0.865033
vn -0.000000 -0.000000 1.000000
vn -0.000000 -0.501714 0.865033
vn -0.000000 -0.867044 0.498231
vn -0.249116 0.867044 0.431481
vn -0.432517 0.501714 0.749141
vn -0.500000 -0.000000 0.866025
vn -0.432517 -0.501714 0.749141
vn -0.249116 -0.867044 0.431481
vn -0.431481 0.867044 0.249116
vn -0.749141 0.501714 0.432517
vn -0.866025 -0.000000 0.500000
vn -0.749141 -0.501714 0.432517
vn -0.431481 -0.867044 0.249116
vn -0.498231 0.867044 -0.000000
vn -0.865033 0.501714 -0.000000
vn -1.000000 0.000000 -0.000000
vn -0.865033 -0.501714 -0.000000
vn -0.498231 -0.867044 -0.000000
vn -0.431481 0.867044 -0.249116
vn -0.749141 0.501714 -0.432517
vn -0.866025 0.000000 -0.500000
vn -0.749141 -0.501714 -0.432517
vn -0.431481 -0.867044 -0.249116
vn -0.249116 0.867044 -0.431481
vn -0.432517 0.501714 -0.749141
vn -0.500000 0.000000 -0.866025
vn -0.432517 -0.501714 -0.749141
vn -0.249116 -0.867044 -0.431481
vn 0.000000 0.867044 -0.498231
vn 0.000000 0.501714 -0.865033
vn 0.000000 0.000000 -1.000000
vn 0.000000 -0.501714 -0.865033
vn 0.000000 -0.867044 -0.498231
vn 0.249116 0.867044 -0.431481
vn 0.432517 0.501714 -0.749141
vn 0.500000 0.000000 -0.866025
vn 0.432517 -0.501715 -0.749141
vn 0.249116 -0.867044 -0.431481
vn 0.431481 0.867044 -0.249116
vn 0.749141 0.501714 -0.432517
vn 0.866025 0.000000 -0.500000
vn 0.749141 -0.501715 -0.432517
vn 0.431481 -0.867044 -0.249116
vn -0.000000 1.000000 -0.000000
vn 0.000000 -1.000000 -0.000000
vt 0.871287 0.285637
vt 0.928725 0.500000
vt 0.747525 0.500000
vt 0.714363 0.376238
vt 0.928725 0.252475
vt 0.995049 0.500000
vt 0.871287 0.285637
vt 0.928725 0.500000
vt 0.714363 0.376238
vt 0.747525 0.500000
vt 0.500000 0.500000
vt 0.500000 0.500000
vt 0.714363 0.128713
vt 0.623762 0.285637
vt 0.747525 0.071275
vt 0.714363 0.128713
vt 0.623762 0.285637
vt 0.500000 0.071275
vt 0.500000 0.252475
vt 0.500000 0.004950
vt 0.500000 0.071275
vt 0.500000 0.252475
vt 0.285637 0.128713
vt 0.376238 0.285637
vt 0.252475 0.071275
vt 0.285637 0.128713
vt 0.376238 0.285637
vt 0.128713 0.285637
vt 0.285637 0.376238
vt 0.071275 0.252475
vt 0.128713 0.285637
vt 0.285637 0.376238
vt 0.071275 0.500000
vt 0.252475 0.500000
vt 0.004950 0.500000
vt 0.071275 0.500000
vt 0.252475 0.500000
vt 0.128713 0.714363
vt 0.285637 0.623762
vt 0.071275 0.747525
vt 0.128713 0.714363
vt 0.285637 0.623762
vt 0.285637 0.871287
vt 0.376238 0.714363
vt 0.252475 0.928725
vt 0.285637 0.871287
vt 0.376238 0.714363
vt 0.500000 0.928725
vt 0.500000 0.747525
vt 0.500000 0.995049
vt 0.500000 0.928725
vt 0.500000 0.747525
vt 0.714363 0.871287
vt 0.623762 0.714363
vt 0.747525 0.928725
vt 0.714363 0.871287
vt 0.623762 0.714363
vt 0.871287 0.714363
vt 0.714363 0.623762
vt 0.928725 0.747525
vt 0.871287 0.714363
vt 0.714363 0.623762
f 7/1/7 2/2/2 1/3/1 6/4/6
f 8/5/8 3/6/3 2/2/2 7/1/7
f 9/7/9 4/8/4 3/6/3 8/5/8
f 10/9/10 5/10/5 4/8/4 9/7/9
f 6/4/6 1/3/1 61/11/61
f 5/10/5 10/9/10 62/12/62
f 12/13/12 7/1/7 6/4/6 11/14/11
f 13/15/13 8/5/8 7/1/7 12/13/12
f 14/16/14 9/7/9 8/5/8 13/15/13
f 15/17/15 10/9/10 9/7/9 14/16/14
f 11/14/11 6/4/6 61/11/61
f 10/9/10 15/17/15 62/12/62
f 17/18/17 12/13/12 11/14/11 16/19/16
f 18/20/18 13/15/13 12/13/12 17/18/17
f 19/21/19 14/16/14 13/15/13 18/20/18
f 20/22/20 15/17/15 14/16/14 19/21/19
f 16/19/16 11/14/11 61/11/61
f 15/17/15 20/22/20 62/12/62
f 22/23/22 17/18/17 16/19/16 21/24/21
f 23/25/23 18/20/18 17/18/17 22/23/22
f 24/26/24 19/21/19 18/20/18 23/25/23
f 25/27/25 20/22/20 19/21/19 24/26/24
f 21/24/21 16/19/16 61/11/61
f 20/22/20 25/27/25 62/12/62
f 27/28/27 22/23/22 21/24/21 26/29/26
f 28/30/28 23/25/23 22/23/22 27/28/27
f 29/31/29 24/26/24 23/25/23 28/30/28
f 30/32/30 25/27/25 24/26/24 29/31/29
f 26/29/26 21/24/21 61/11/61
f 25/27/25 30/32/30 62/12/62
f 32/33/32 27/28/27 26/29/26 31/34/31
f 33/35/33 28/30/28 27/28/27 32/33/32
f 34/36/34 29/31/29 28/30/28 33/35/33
f 35/37/35 30/32/30 29/31/29 34/36/34
f 31/34/31 26/29/26 61/11/61
f 30/32/30 35/37/35 62/12/62
f 37/38/37 32/33/32 31/34/31 36/39/36
f 38/40/38 33/35/33 32/33/32 37/38/37
f 39/41/39 34/36/34 33/35/33 38/40/38
f 40/42/40 35/37/35 34/36/34 39/41/39
f 36/39/36 31/34/31 61/11/61
f 35/37/35 40/42/40 62/12/62
f 42/43/42 37/38/37 36/39/36 41/44/41
f 43/45/43 38/40/38 37/38/37 42/43/42
f 44/46/44 39/41/39 38/40/38 43/45/43
f 45/47/45 40/42/40 39/41/39 44/46/44
f 41/44/41 36/39/36 61/11/61
f 40/42/40 45/47/45 62/12/62
f 47/48/47 42/43/42 41/44/41 46/49/46
f 48/50/48 43/45/43 42/43/42 47/48/47
f 49/51/49 44/46/44 43/45/43 48/50/48
f 50/52/50 45/47/45 44/46/44 49/51/49
f 46/49/46 41/44/41 61/11/61
f 45/47/45 50/52/50 62/12/62
f 52/53/52 47/48/47 46/49/46 51/54/51
f 53/55/53 48/50/48 47/48/47 52/53/52
f 54/56/54 49/51/49 48/50/48 53/55/53
f 55/57/55 50/52/50 49/51/49 54/56/54
f 51/54/51 46/49/46 61/11/61
f 50/52/50 55/57/55 62/12/62
f 57/58/57 52/53/52 51/54/51 56/59/56
f 58/60/58 53/55/53 52/53/52 57/58/57
f 59/61/59 54/56/54 53/55/53 58/60/58
f 60/62/60 55/57/55 54/56/54 59/61/59
f 56/59/56 51/54/51 61/11/61
f 55/57/55 60/62/60 62/12/62
f 2/2/2 57/58/57 56/59/56 1/3/1
f 3/6/3 58/60/58 57/58/57 2/2/2
f 4/8/4 59/61/59 58/60/58 3/6/3
f 5/10/5 60/62/60 59/61/59 4/8/4
f 1/3/1 56/59/56 61/11/61
f 60/62/60 5/10/5 62/12/62
""")


#
# AppleseedExportOperator class.
#

class AppleseedExportOperator(bpy.types.Operator):
    bl_idname = "appleseed.export"
    bl_label = "Export"

    # The name of the appleseed project file.
    filepath = bpy.props.StringProperty(subtype='FILE_PATH')

    # The scene to export.
    selected_scene = bpy.props.EnumProperty(name="Scene",
                                            description="Select the scene to export",
                                            items=scene_enumerator)

    # The camera to export.
    selected_camera = bpy.props.EnumProperty(name="Camera",
                                             description="Select the camera to export",
                                             items=camera_enumerator)

    # Number of samples per pixels in final frame mode.
    sample_count = bpy.props.IntProperty(name="Sample Count",
                                         description="Number of samples per pixels in final frame mode",
                                         min=1,
                                         max=4096,
                                         default=32)

    # Should the mesh files (.obj files) be regenerated?
    generate_mesh_files = bpy.props.BoolProperty(name="Write Meshes to Disk",
                                                 default=True)

    # Transformation matrix that is applied to all entities of the scene.
    global_matrix = mathutils.Matrix.Scale(0.1, 4)

    def execute(self, context):
        if EnableProfiling:
            dis.dis(get_vector3_key)
            cProfile.runctx("self.export()", globals(), locals())
        else: self.export()
        return { 'FINISHED' }

    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return { 'RUNNING_MODAL' }

    def __get_selected_scene(self):
        if self.selected_scene is not None and self.selected_scene in bpy.data.scenes:
            return bpy.data.scenes[self.selected_scene]
        else: return None

    def __get_selected_camera(self):
        if self.selected_camera is not None and self.selected_camera in bpy.data.objects:
            return bpy.data.objects[self.selected_camera]
        else: return None

    def export(self):
        scene = self.__get_selected_scene()

        if scene is None:
            self.__error("No scene to export.")
            pass

        # The set of materials that were already emitted.
        self._emitted_materials = set()

        file_path = os.path.splitext(self.filepath)[0] + ".appleseed"

        self.__info("")
        self.__info("Starting export of scene '{0}' to {1}...".format(scene.name, file_path))

        start_time = datetime.now()

        try:
            with open(file_path, "w") as self._output_file:
                self._indent = 0
                self.__emit_file_header()
                self.__emit_project(scene)
        except IOError:
            self.__error("Could not write to {0}.".format(file_path))
            return

        elapsed_time = datetime.now() - start_time
        self.__info("Finished exporting in {0}".format(elapsed_time))

    def __emit_file_header(self):
        self.__emit_line("<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
        self.__emit_line("<!-- File generated by {0} {1}. -->".format(script_name, get_version_string()))

    def __emit_project(self, scene):
        self.__open_element("project")
        self.__emit_scene(scene)
        self.__emit_output(scene)
        self.__emit_configurations()
        self.__close_element("project")

    def __emit_scene(self, scene):
        self.__open_element("scene")
        self.__emit_camera(scene)
        self.__emit_assembly(scene)
        self.__emit_assembly_instance(scene)
        self.__close_element("scene")

    def __emit_camera(self, scene):
        camera = self.__get_selected_camera()

        if camera is None:
            self.__warning("No camera in the scene, exporting a default camera.")
            self.__emit_default_camera()
            return

        render = scene.render

        film_width = 32.0 / 1000                                # Blender's film width is hardcoded to 32 mm
        aspect_ratio = self.__get_frame_aspect_ratio(render)
        focal_length = camera.data.lens / 1000.0                # Blender's camera focal length is expressed in mm

        camera_matrix = self.global_matrix * camera.matrix_world
        origin = camera_matrix[3]
        forward = -camera_matrix[2]
        up = camera_matrix[1]
        target = origin + forward

        self.__open_element('camera name="' + camera.name + '" model="pinhole_camera"')
        self.__emit_parameter("film_width", film_width)
        self.__emit_parameter("aspect_ratio", aspect_ratio)
        self.__emit_parameter("focal_length", focal_length)
        self.__open_element("transform")
        self.__emit_line('<look_at origin="{0} {1} {2}" target="{3} {4} {5}" up="{6} {7} {8}" />'.format( \
                         origin[0], origin[2], -origin[1],
                         target[0], target[2], -target[1],
                         up[0], up[2], -up[1]))
        self.__close_element("transform")
        self.__close_element("camera")

    def __emit_default_camera(self):
        self.__open_element('camera name="camera" model="pinhole_camera"')
        self.__emit_parameter("film_width", 0.024892)
        self.__emit_parameter("film_height", 0.018669)
        self.__emit_parameter("focal_length", 0.035)
        self.__close_element("camera")
        return

    def __emit_assembly(self, scene):
        self.__open_element('assembly name="' + scene.name + '"')
        self.__emit_physical_surface_shader()
        self.__emit_objects(scene)
        self.__emit_lights(scene)
        self.__close_element("assembly")

    def __emit_physical_surface_shader(self):
        self.__emit_line('<surface_shader name="physical_shader" model="physical_surface_shader" />')

    def __emit_objects(self, scene):
        for object in scene.objects:
            # Skip non-geometric objects.
            if object.type in ( 'CAMERA', 'EMPTY', 'LAMP' ):
                continue

            # Skip non-renderable objects.
            if object.hide_render:
                continue

            # Skip children of dupli objects.
            if object.parent and object.parent.dupli_type != 'NONE':
                continue

            # Create dupli list.
            if object.dupli_type != 'NONE':
                object.dupli_list_create(scene)
                root_object = object.dupli_list[0][0]
                instance_matrices = [ dupli.matrix for dupli in object.dupli_list ]
            else:
                root_object = object
                instance_matrices = [ object.matrix_world ]

            # Emit the object and all its instances.
            self.__emit_object_and_instances(scene, root_object, instance_matrices)

            # Clear dupli list.
            if object.dupli_type != 'NONE':
                object.dupli_list_clear()

    def __emit_object_and_instances(self, scene, object, instance_matrices):
        try:
            mesh = object.to_mesh(scene, True, 'RENDER')
            self.__do_emit_object_and_instances(scene, object, mesh, instance_matrices)
            bpy.data.meshes.remove(mesh)
        except RuntimeError:
            self.__info("Failed to convert object '{0}' of type '{1}' to a mesh.".format(object.name, object.type))

    def __do_emit_object_and_instances(self, scene, object, mesh, instance_matrices):
        if len(mesh.faces) == 0:
            self.__info("Skipping object '{0}' since it has no faces once converted to a mesh.".format(object.name))
            return

        # Recalculate vertex normals.
        # todo: make this step optional?
        mesh.calc_normals()

        filename = object.name + ".obj"

        # Export mesh to disk.
        if self.generate_mesh_files:
            try:
                filepath = os.path.join(os.path.dirname(self.filepath), filename)
                self.__progress("Exporting object '{0}' to {1}...".format(object.name, filename))
                write_mesh_to_disk(mesh, filepath)
            except IOError:
                self.__error("While exporting object '{0}': could not write to {1}, skipping this object.".format(object.name, filepath))
                return

        # Emit object.
        self.__emit_object(object.name, filename)

        # Collect materials.
        materials = [ material_slot.material for material_slot in object.material_slots ]
        if len(materials) == 0:
            materials = [ bpy.data.materials.new(name="{0}_material".format(object.name)) ]

        # Emit BSDFs and materials.
        for material_index, material in enumerate(materials):
            if material not in self._emitted_materials:
                self.__emit_bsdf_and_material(material)
                self._emitted_materials.add(material)

        self.__info("Object '{0}' has {1} instances and {2} materials.".format(object.name, len(instance_matrices), len(materials)))

        # Emit object instances.
        for material_index, material in enumerate(materials):
            part_name = "{0}.part_{1}".format(object.name, material_index)
            for instance_index, instance_matrix in enumerate(instance_matrices):
                instance_name = "{0}.instance_{1}".format(part_name, instance_index)
                self.__emit_object_instance(part_name, instance_name, self.global_matrix * instance_matrix, material.name)

    def __emit_bsdf_and_material(self, material):
        bsdf_name = "{0}_bsdf".format(material.name)
        self.__emit_bsdf(material, bsdf_name)
        self.__emit_material(material.name, bsdf_name, "")

    def __emit_bsdf(self, material, bsdf_name):
        if is_black(material.specular_color * material.specular_intensity):
            self.__emit_lambertian_brdf(material, bsdf_name)
        else:
            self.__emit_ashikhmin_brdf(material, bsdf_name)

    def __emit_lambertian_brdf(self, material, bsdf_name):
        reflectance_name = "{0}_reflectance".format(bsdf_name)
        self.__emit_color(reflectance_name, material.diffuse_color, material.diffuse_intensity)

        self.__open_element('bsdf name="{0}" model="lambertian_brdf"'.format(bsdf_name))
        self.__emit_parameter("reflectance", reflectance_name)
        self.__close_element("bsdf")

    def __emit_ashikhmin_brdf(self, material, bsdf_name):
        diffuse_reflectance_name = "{0}_diffuse_reflectance".format(bsdf_name)
        glossy_reflectance_name = "{0}_glossy_reflectance".format(bsdf_name)

        self.__emit_color(diffuse_reflectance_name, material.diffuse_color, material.diffuse_intensity)
        self.__emit_color(glossy_reflectance_name, material.specular_color, material.specular_intensity)

        self.__open_element('bsdf name="{0}" model="ashikhmin_brdf"'.format(bsdf_name))
        self.__emit_parameter("diffuse_reflectance", diffuse_reflectance_name)
        self.__emit_parameter("glossy_reflectance", glossy_reflectance_name)
        self.__emit_parameter("shininess_u", material.specular_hardness)
        self.__emit_parameter("shininess_v", material.specular_hardness)
        self.__close_element("bsdf")

    def __emit_material(self, material_name, bsdf_name, edf_name):
        self.__open_element('material name="{0}" model="generic_material"'.format(material_name))
        if len(bsdf_name) > 0:
            self.__emit_parameter("bsdf", bsdf_name)
        if len(edf_name) > 0:
            self.__emit_parameter("edf", edf_name)
        self.__emit_parameter("surface_shader", "physical_shader")
        self.__close_element("material")

    def __emit_color(self, name, values, multiplier):
        self.__open_element('color name="{0}"'.format(name))
        self.__emit_parameter("color_space", "srgb")
        self.__emit_parameter("multiplier", multiplier)
        self.__emit_line("<values>{0} {1} {2}</values>".format(values[0], values[1], values[2]))
        self.__close_element("color")

    def __emit_object(self, object_name, filename):
        self.__open_element('object name="' + object_name + '" model="mesh_object"')
        self.__emit_parameter("filename", filename)
        self.__close_element("object")

    def __emit_object_instance(self, object_name, instance_name, instance_matrix, material_name):
        self.__open_element('object_instance name="{0}" object="{1}"'.format(instance_name, object_name))
        self.__emit_transform(instance_matrix)
        self.__emit_line('<assign_material slot="0" material="{0}" />'.format(material_name))
        self.__close_element("object_instance")

    def __emit_lights(self, scene):
        filename = "__spherical_light.obj"

        if self.generate_mesh_files:
            filepath = os.path.join(os.path.dirname(self.filepath), filename)
            self.__progress("Emitting built-in object 'spherical_light' to {0}...".format(filename))
            write_sphere_mesh_to_disk(filepath)

        self.__emit_object("__spherical_light", filename)

        for object in scene.objects:
            if object.type == 'LAMP':
                self.__emit_light(scene, object)

    def __emit_light(self, scene, lamp):
        lamp_size = 0.1
        lamp_energy_multipler = 10

        material_name = "{0}_material".format(lamp.name)
        edf_name = "{0}_edf".format(material_name)
        exitance_name = "{0}_exitance".format(edf_name)

        self.__emit_color(exitance_name, lamp.data.color, lamp.data.energy * lamp_energy_multipler)

        self.__open_element('edf name="{0}" model="diffuse_edf"'.format(edf_name))
        self.__emit_parameter("exitance", exitance_name)
        self.__close_element("edf")

        self.__emit_material(material_name, "", edf_name)

        matrix = self.global_matrix * lamp.matrix_world
        matrix = matrix * mathutils.Matrix.Scale(lamp_size, 4)
        self.__emit_object_instance("__spherical_light.0", lamp.name, matrix, material_name)

    def __emit_assembly_instance(self, scene):
        self.__open_element('assembly_instance name="' + scene.name + '_instance" assembly="' + scene.name + '"')
        self.__close_element("assembly_instance")

    def __emit_output(self, scene):
        self.__open_element("output")
        self.__emit_frame(scene)
        self.__close_element("output")

    def __emit_frame(self, scene):
        camera = self.__get_selected_camera()
        width, height = self.__get_frame_resolution(scene.render)
        self.__open_element("frame name=\"beauty\"")
        self.__emit_parameter("camera", "camera" if camera is None else camera.name)
        self.__emit_parameter("resolution", "{0} {1}".format(width, height))
        self.__emit_custom_prop(scene, "color_space", "srgb")
        self.__close_element("frame")

    def __get_frame_resolution(self, render):
        scale = render.resolution_percentage / 100.0
        width = int(render.resolution_x * scale)
        height = int(render.resolution_y * scale)
        return width, height

    def __get_frame_aspect_ratio(self, render):
        width, height = self.__get_frame_resolution(render)
        xratio = width * render.pixel_aspect_x
        yratio = height * render.pixel_aspect_y
        return xratio / yratio

    def __emit_configurations(self):
        self.__open_element("configurations")
        self.__emit_interactive_configuration()
        self.__emit_final_configuration()
        self.__close_element("configurations")

    def __emit_interactive_configuration(self):
        self.__open_element('configuration name="interactive" base="base_interactive"')
        self.__close_element("configuration")

    def __emit_final_configuration(self):
        self.__open_element('configuration name="final" base="base_final"')
        self.__open_element('parameters name="generic_tile_renderer"')
        self.__emit_parameter("min_samples", self.sample_count)
        self.__emit_parameter("max_samples", self.sample_count)
        self.__close_element('parameters')
        self.__close_element("configuration")

    def __emit_transform(self, matrix):
        s = matrix.to_scale()
        t = matrix.to_translation()
        rx, ry, rz = map(rad_to_deg, matrix.to_euler())

        self.__open_element("transform")
        self.__emit_line('<scaling value="{0} {1} {2}" />'.format(s[0], s[2], s[1]))
        self.__emit_line('<rotation axis="1.0 0.0 0.0" angle="{0}" />'.format(rx))
        self.__emit_line('<rotation axis="0.0 0.0 -1.0" angle="{0}" />'.format(ry))
        self.__emit_line('<rotation axis="0.0 1.0 0.0" angle="{0}" />'.format(rz))
        self.__emit_line('<translation value="{0} {1} {2}" />'.format(t[0], t[2], -t[1]))
        self.__close_element("transform")

    def __emit_custom_prop(self, object, prop_name, default_value):
        value = self.__get_custom_prop(object, prop_name, default_value)
        self.__emit_parameter(prop_name, value)

    def __get_custom_prop(self, object, prop_name, default_value):
        if prop_name in object:
            return object[prop_name]
        else:
            return default_value

    def __emit_parameter(self, name, value):
        self.__emit_line("<parameter name=\"" + name + "\" value=\"" + str(value) + "\" />")

    def __open_element(self, name):
        self.__emit_line("<" + name + ">")
        self.__indent()

    def __close_element(self, name):
        self.__unindent()
        self.__emit_line("</" + name + ">")

    def __emit_line(self, line):
        self.__emit_indent()
        self._output_file.write(line + "\n")

    def __indent(self):
        self._indent += 1

    def __unindent(self):
        assert self._indent > 0
        self._indent -= 1

    def __emit_indent(self):
        IndentSize = 4
        self._output_file.write(" " * self._indent * IndentSize)

    def __error(self, message):
        self.__print_message("error", message)
        self.report({ 'ERROR' }, message)

    def __warning(self, message):
        self.__print_message("warning", message)
        self.report({ 'WARNING' }, message)

    def __info(self, message):
        if len(message) > 0:
            self.__print_message("info", message)
        else: print("")
        self.report({ 'INFO' }, message)

    def __progress(self, message):
        self.__print_message("progress", message)

    def __print_message(self, severity, message):
        max_length = 8  # length of the longest severity string
        padding_count = max_length - len(severity)
        padding = " " * padding_count
        print("[{0}] {1}{2} : {3}".format(script_name, severity, padding, message))


#
# Hook into Blender.
#

def menu_func(self, context):
    default_path = os.path.splitext(bpy.data.filepath)[0] + ".appleseed"
    self.layout.operator(AppleseedExportOperator.bl_idname, text="appleseed (.appleseed)").filepath = default_path

def register():
    bpy.utils.register_module(__name__)
    bpy.types.INFO_MT_file_export.append(menu_func)

def unregister():
    bpy.types.INFO_MT_file_export.remove(menu_func)
    bpy.utils.unregister_module(__name__)


#
# Entry point.
#

if __name__ == "__main__":
    register()
